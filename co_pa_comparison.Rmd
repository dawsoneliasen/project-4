---
title: 'Colorado-Pennsylvania Redistricting Comparison'
author: 'Dawson Eliasen'
date: '12/1/2020'
output: pdf_document
---

```{r}
library(redist)
library(sf)
library(maptools)
library(coda)
library(tidyverse)
library(plyr)
library(Rcpp)
library(ggthemes)
library(RColorBrewer)
```



## Introduction 

  Fair elections are a integral part of democracy for without it, the will of the people might not be respected and if that happens we no longer have a democracy. However, despite the huge importance of the elections in the US, there are still ways that a party can negatively impact the election by gaining an unfair advantage. One of the ways that this can happen, is gerrymandering where in order to gain a political advantage in a state by manipulating district boundaries. This issues has come before the supreme court, however it was ruled that it was up to the congress and the states to deal with it.
  
  Due to the scale of this issue, the paper by Fifield et al, proposes the use of a Markov Chain Monte Carlo method to automate the redistricting process, despite having a few Monte Carlo algorithms existing none of them have strong theoretical background. Fifield et al algorithm proposes to solve the automation redistricting by formulating it as a Graph Cut problem, where the MCMC samples the districts plans from arbitrary distributions over the set of n contiguous districts, they also implemented equal population constraint, which is a main requirement in the real-world problem. 


  









## Function definitions

```{r}
sourceCpp('cpp/count_seats.cpp', rebuild=TRUE)
sourceCpp('cpp/pBias.cpp', rebuild=TRUE)
```

```{r}
# function to calculate bias from district map
# (code adapted from the paper replication code paper/fig5_fig6/fig5_fig6.R)
calc_sim_bias <- function(algout, dem_vote, rep_vote, range=0.1) {
    statebase <- sum(dem_vote) / (sum(dem_vote) + sum(rep_vote))
    equal <- .5 - statebase
    inc <- seq(0, range, by=.01)
    bias <- unique(c(rev(equal - inc), equal + inc))
    repseats <- matrix(NA, nrow=ncol(algout), ncol=length(bias))
    for(j in 1:length(bias)){
      repseats[,j] <- pBias(dem_vote, rep_vote, algout, bias[j])
      # print(j)
    }
    # make bias correspond to deviation from 50-50; convert to seat share
    bias <- seq(-1 * range, range, length=length(bias))
    dists <- length(unique(algout[,1]))
    repseats <- repseats / dists
    repseats <- 1 - repseats
    # plot step function
    xmin <- -1 * range
    xmax <- range
    # calculate bias - get change points
    storebias <- rep(NA, nrow(repseats))
    for(j in 1:nrow(repseats)){
      swing <- repseats[j,]
      # get the bias
      mod <- lm(swing ~ bias)
      null <- predict(mod, data.frame(bias=bias))
      # calculate the area
      gt0_area <- geiger:::.area.between.curves(bias[which(bias > 0)],
                                                null[which(bias > 0)],
                                                swing[which(bias > 0)],
                                                xrange=c(-1,1))
      lt0_area <- geiger:::.area.between.curves(bias[which(bias <= 0)],
                                                null[which(bias <= 0)],
                                                swing[which(bias <= 0)],
                                                xrange=c(-1,1))
      bias_area <- gt0_area + lt0_area
      storebias[j] <- bias_area
    }
    return (storebias)
}


# function to plot the simulation result with minimum bias
# (code adapted from the paper replication code paper/fig5_fig6/fig5_fig6.R)
plot_min_bias <- function(algout, storebias, map, xax, mindev=0.02875, maxdev=0.03125) {
    # ind <- which(storebias == min(storebias[xax < maxdev & xax > mindev]))[1]
    ind <- which(storebias == min(abs(storebias)))[1]
    min_map <- algout[,ind]
    map$new_districts <- as.factor(min_map)
    ggplot(map, aes(fill=new_districts)) +
      geom_sf(size=0) +
      scale_fill_brewer(palette='Set2')
}


# function to plot bias of each simulation instance (fig. 5)
# (code adapted from the paper replication code paper/fig5_fig6/fig5_fig6.R)
plot_sim_bias <- function(xax, storebias, range=0.1) {
    bias_min <- - (range - -1 * range) * 1 / 2
    bias_max <- (range - -1 * range) * 1 / 2
    # plot xax
    test <- (1 - -1) * (tapply(storebias,  round(xax, 4), mean) - bias_min) / 
        (bias_max - bias_min) + -1
    x <- as.numeric(names(test)) 
    n <- table(round(xax, 4))
    par(mfrow=c(1,1), mar=c(4.1, 4.3, 2.1, 1.0))
    # colrep <- rep('black', length(test[x<.05]))
    colrep <- rep('black', length(test))
    plot(
        # x[x<.05], test[x<.05], cex=n^(1/100), pch=16,
        x, test, cex=n^(1/100), pch=16,
        ylim=c(0, max(test)),
        main='Partisan Bias of Simulated Plans',
        xlab='% of Precincts Switched From Original District',
        ylab='Partisan Bias towards Democrats',
        xaxt='n',
        cex.lab=1.6,
        cex.axis=1.7,
        cex.main=1.6,
        col=colrep
     )
    axis(
      1,
      seq(0, max(x), by=0.05),
      as.character(seq(0, max(x), by=0.05)),
      cex.axis=1.7
    )
    abline(h=(1 - -1) * (storebias[1] - bias_min) / (bias_max - bias_min) + -1)
    abline(h=0, col='red', lty='dashed')
}
```

## Read data

```{r}
co <- read_sf(dsn='co_precincts', layer='co_precincts')
co <- co %>% arrange(CD116FP)
from <- unique(co$CD116FP)
to <- seq_len(length(unique(co$CD116FP)))
co$CD116FP <- co$CD116FP %>% mapvalues(from, to)

loadRData <- function(f) {
    load(f)
    get(ls()[ls() != 'f'])
}

co_sim1 <- loadRData('co_redist_mcmc1.RData')
co_sim2 <- loadRData('co_redist_mcmc2.RData')
co_sim3 <- loadRData('co_redist_mcmc3.RData')
# TODO: are these the correct columns to use from Colorado data?
co_sim1_seg <- redist.segcalc(co_sim1, co$USH18R, co$TOTPOP)
co_sim2_seg <- redist.segcalc(co_sim2, co$USH18R, co$TOTPOP)
co_sim3_seg <- redist.segcalc(co_sim3, co$USH18R, co$TOTPOP)
co_sim <- cbind(co_sim1$partitions[,!is.na(co_sim1_seg)],
                co_sim2$partitions[,!is.na(co_sim2_seg)], 
                co_sim3$partitions[,!is.na(co_sim3_seg)])
xax <- 1 - c(co_sim1$distance_original[!is.na(co_sim1_seg)],
             co_sim2$distance_original[!is.na(co_sim2_seg)],
             co_sim3$distance_original[!is.na(co_sim3_seg)])
```

## Reproduce plots

```{r}
# TODO: are these the correct columns to use from Colorado data?
co_sim_bias <- calc_sim_bias(co_sim, co$GOV18D, co$GOV18R)
plot_sim_bias(xax, co_sim_bias)
```
```{r}
dev.print(png, 'figures/bias.png')
```


```{r}
plot_min_bias(co_sim, co_sim_bias, co, xax)
ggsave('figures/min_bias_map.png')
```

