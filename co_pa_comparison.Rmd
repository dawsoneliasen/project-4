---
title: 'Colorado-Pennsylvania Redistricting Comparison'
author: 'Dawson Eliasen'
date: '12/1/2020'
output: pdf_document
---

```{r}
library(redist)
library(sf)
library(maptools)
library(coda)
library(tidyverse)
library(Rcpp)
library(ggthemes)
library(RColorBrewer)
```



## Introduction 

  Fair elections are a integral part of democracy for without it, the will of the people might not be respected and if that happens we no longer have a democracy. However, despite the huge importance of the elections in the US, there are still ways that a party can negatively impact the election by gaining an unfair advantage. One of the ways that this can happen, is gerrymandering where in order to gain a political advantage in a state by manipulating district boundaries.









## Function definitions

```{r}
sourceCpp('cpp/count_seats.cpp', rebuild=TRUE)
sourceCpp('cpp/pBias.cpp', rebuild=TRUE)
```

```{r}
# function to calculate bias from district map
# (code adapted from the paper replication code paper/fig5_fig6/fig5_fig6.R)
calc_sim_bias <- function(algout, dem_vote, rep_vote, range=0.1) {
    statebase <- sum(dem_vote) / (sum(dem_vote) + sum(rep_vote))
    equal <- .5 - statebase
    inc <- seq(0, range, by=.01)
    bias <- unique(c(rev(equal - inc), equal + inc))
    # algout <- cbind(c1$partitions[,!is.na(c1_seg)], c2$partitions[,!is.na(c2_seg)], 
    #                 c3$partitions[,!is.na(c3_seg)])
    repseats <- matrix(NA, nrow=ncol(algout), ncol=length(bias))
    for(j in 1:length(bias)){
      repseats[,j] <- pBias(dem_vote, rep_vote, algout, bias[j])
      # print(j)
    }
    # make bias correspond to deviation from 50-50; convert to seat share
    bias <- seq(-1 * range, range, length=length(bias))
    dists <- length(unique(algout[,1]))
    repseats <- repseats / dists
    repseats <- 1 - repseats
    # plot step function
    xmin <- -1 * range
    xmax <- range
    # calculate bias - get change points
    storebias <- rep(NA, nrow(repseats))
    for(j in 1:nrow(repseats)){
      swing <- repseats[j,]
      # get the bias
      mod <- lm(swing ~ bias)
      null <- predict(mod, data.frame(bias=bias))
      # alculate the area
      gt0_area <- geiger:::.area.between.curves(bias[which(bias > 0)],
                                               null[which(bias > 0)],
                                               swing[which(bias > 0)],
                                               xrange=c(-1,1))
      lt0_area <- geiger:::.area.between.curves(bias[which(bias <= 0)],
                                                null[which(bias <= 0)],
                                                swing[which(bias <= 0)],
                                                xrange=c(-1,1))
      bias_area <- gt0_area + lt0_area
      storebias[j] <- bias_area
      if(j %% 1000 == 0){
        # print(j)
      }
    }
    return (storebias)
}


# function to plot the simulation result with minimum bias
# (code adapted from the paper replication code paper/fig5_fig6/fig5_fig6.R)
plot_min_bias <- function(algout, storebias) {
    mindev <- .02875
    maxdev <- .03125
    ind <- which(storebias == min(storebias[xax < maxdev & xax > mindev]))[1]
    orig_map <- algout[,1] + 1
    min_map <- algout[,ind] + 1
    
    map@data$orig_map <- orig_map
    map@data$min_map <- min_map
    map@data$unchanged <- orig_map == min_map
    
    # map@data %>% group_by(orig_map) %>%
    #     summarise(demvote=sum(USCDV2008)/sum(USCDV2008 + USCRV2008),
    #               sharediff=mean(unchanged))
    
    map@data$dem_voteshare <- map@data$USCDV2008 /
        (map@data$USCDV2008 + map@data$USCRV2008)
    map@data$col[!is.na(map@data$dem_voteshare)] <- rgb(
        red=(1 - map@data$dem_voteshare[!is.na(map@data$dem_voteshare)]),
        green=0,
        blue=map@data$dem_voteshare[!is.na(map@data$dem_voteshare)],
        alpha=.5
    )
    
    mapsub_1 <- map[map$orig_map == 1 | map$min_map == 1,]
    mapsub_1$col <- ifelse(mapsub_1$orig_map == mapsub_1$min_map, 'white',
                     ifelse(mapsub_1$orig_map == 1, 'blue', 'red'))
    
    dist <- 3
    mapsub_dist <- map[map$orig_map == dist | map$min_map == dist,]
    mapsub_dist$col <- ifelse(mapsub_dist$orig_map == mapsub_dist$min_map, 'white',
                       ifelse(mapsub_dist$orig_map == dist, 'blue', 'red'))
}


# function to plot bias of each simulation instance (fig. 5)
# (code adapted from the paper replication code paper/fig5_fig6/fig5_fig6.R)
plot_sim_bias <- function(xax, storebias, range=0.1) {
    bias_min <- - (range - -1 * range) * 1 / 2
    bias_max <- (range - -1 * range) * 1 / 2
    # plot xax
    test <- (1 - -1) * (tapply(storebias,  round(xax, 4), mean) - bias_min) / 
        (bias_max - bias_min) + -1
    x <- as.numeric(names(test)) 
    n <- table(round(xax, 4))
    par(mfrow=c(1,1), mar=c(4.1, 4.3, 2.1, 1.0))
    colrep <- rep('black', length(test[x<.05]))
    colrep[196] <- 'red'
    plot(
        x[x<.05], test[x<.05], cex=n^(1/100), pch=16,
        ylim=c(0, max(test[x<.05])),
        main='Partisan Bias of Simulated Plans',
        xlab='% of Precincts Switched From Original District',
        ylab='Partisan Bias towards Democrats',
        xaxt='n',
        cex.lab=1.6,
        cex.axis=1.7,
        cex.main=1.6,
        col=colrep
     )
    axis(1, seq(0, 0.05, by=0.01), c('0%', '1%', '2%', '3%', '4%', '5%'), cex.axis=1.7)
    abline(h=(1 - -1) * (storebias[1] - bias_min) / (bias_max - bias_min) + -1)
    abline(h=0, col='red', lty='dashed')
}
```

## Read data

```{r}
co <- read_sf(dsn='co_precincts', layer='co_precincts')
pa <- read_sf(dsn='pa', layer='pa_final')

loadRData <- function(f) {
    load(f)
    get(ls()[ls() != 'f'])
}

co_sim1 <- loadRData('co_redist_mcmc1.RData')
co_sim2 <- loadRData('co_redist_mcmc2.RData')
co_sim3 <- loadRData('co_redist_mcmc3.RData')
# TODO: are these the correct columns to use from Colorado data?
co_sim1_seg <- redist.segcalc(co_sim1, co$GOV18R, co$TOTPOP)
co_sim2_seg <- redist.segcalc(co_sim2, co$GOV18R, co$TOTPOP)
co_sim3_seg <- redist.segcalc(co_sim3, co$GOV18R, co$TOTPOP)
co_sim <- cbind(co_sim1$partitions[!is.na(co_sim1_seg)],
                co_sim2$partitions[!is.na(co_sim2_seg)], 
                co_sim3$partitions[!is.na(co_sim3_seg)])
xax <- 1 - c(co_sim1$distance_original[!is.na(co_sim1_seg)],
             co_sim2$distance_original[!is.na(co_sim2_seg)],
             co_sim3$distance_original[!is.na(co_sim3_seg)])
```

## Reproduce plots

```{r}
# TODO: are these the correct columns to use from Colorado data?
co_sim_bias <- calc_sim_bias(co_sim, co$GOV18D, co$GOV18R)
plot_sim_bias(xax, co_sim_bias)
```

